{
    "collab_server" : "",
    "contents" : "#\n# This is the server logic of a Shiny web application. You can run the\n# application by clicking 'Run App' above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    http://shiny.rstudio.com/\n#\nlibrary(shiny)\nlibrary(e1071)\nlibrary(corrplot)\nlibrary(boot)\n\n\n##3. Definición de la parte lógica:\n\nmyShinyServer <- function(input, output, session) {\n\n\n\n  ##Función que valida si ya se seleccionó un archivo. Y si se seleccionó, entonce se lee.\n  ##Esta función devuelve los datos \"read_data()\" si hay archivo seleccionado, sino return\n  read_data <- reactive({\n\n\n  if(is.null(input$file1)){\n\n      return()\n\n  }else{\n\n      file1<- input$file1\n      read.table(file=file1$datapath, header=TRUE, sep=\",\", dec=\".\" )\n\n  }\n\n  })\n\n\n  ##Funcion principal que se llama en el Main del UI:\n  ##FUNCIONALIDAD: Se pinta el histograma.\n  output$distPlot <- renderPlot({\n\n\n    ##Se valida si hay datos leidos.\n\n    if(is.null(read_data())){\n\n    }else{\n\n\n     ##---De aquí hacia abajo no se ha cambiado nada\n\n      myData<- read_data()\n\n      #Selección de la columna que contiene la variable de análisis seleccionada por el usuario.\n\n      if(is.numeric(myData[,input$listVar])){\n\n        ##Septiembre 17 de 2017: Se valida si boostrapping está seleccionado\n        ##Si no está seleccinado, se sigue con el análisis normal\n\n\n        datos <<- myData[,input$listVar]\n\n        ##x<- myData[,input$listVar]\n\n        ##2017-09-12: aplicación bootstrapping\n        if (is.null(input$Boots)){\n\n\n          ##Si no está activada la opción de boots no se hace nada.\n\n        }else{\n\n\n          ##De lo contrario, es porque el usuario quiere aplicar bootstrapping.\n          ##Se valida sobre qué estadístico quiere aplicar muestreo el usuario\n          ##para inferir el estadístico que describe la muestra.\n\n          if (input$Boots == \"mean\"){\n\n            call_boots <- boot(data=datos,statistic=fun_mean, R=1000)\n            datos <<- call_boots$t\n\n          }else if (input$Boots == \"median\"){\n\n              call_boots <- boot(data=datos,statistic=fun_median, R=1000)\n              datos <<- call_boots$t\n\n          }else if (input$Boots == \"desviation\") {\n\n            call_boots <- boot(data=datos,statistic=fun_sd, R=1000)\n            datos <<-call_boots$t\n\n          }else if (input$Boots == \"variance\"){\n\n            call_boots <- boot(data=datos,statistic=fun_var, R=1000)\n            datos <<-call_boots$t\n\n          }\n\n        }\n\n\n\n\n        #Generar los bins:\n        bins <- seq(min(datos), max(datos), length.out = input$bins + 1)\n\n\n        #Pintar histograma:\n        hist(datos, main=input$listVar, breaks = bins, col = 'antiquewhite1', border = 'black', freq=FALSE)\n\n\n        ##Se valida el Checkbock de Density, para pontar o no pintar la función de densidad.\n        if(input$Density==TRUE){\n\n          density<-density(datos)\n          lines(density, col = \"red\", lty=2, lwd = 3)\n\n          }\n\n\n        ##Se valida si el Checkbox de Distribuciones está activo.\n        ##Si no está activo, no se hace nada, de lo contrario, se valida cuál esta acitvo.\n        if (is.null(input$Distribution)){\n\n        ##NORMAL:\n        }else if (input$Distribution == \"norm\"){\n\n\n          ##Ajustar la variable a la distribución normal:\n          x=datos\n          curve( dnorm(x, mean=mean(x), sd=sd(x)) , col = \"blue\", lty=2, lwd = 2, add = TRUE)\n\n          ##curve( dnorm(x, mean=10,sd=2), 5, 15, add=T, col=\"blue\")\n\n        ##UNIFORME:\n        }else if (input$Distribution == \"unif\"){\n\n          ##Ajustar la variable a la distribución uniforme:\n          x=datos\n          curve(dunif(x,min=min(x), max=max(x),  log=FALSE), col=\"green\",lty=2, lwd = 2,  add = TRUE)\n\n        ##L-NORMAL:\n        }else if (input$Distribution ==\"lnorm\"){\n\n          ##Ajustar la variable a la distribución LogNormal\n          x=datos\n          curve(dlnorm(x, mean(x), sd(x)),col=25, lty=2, lwd = 2, add = TRUE )\n\n        ##EXPONENCIAL:\n        }else if (input$Distribution ==\"exp\"){\n\n          ##Ajustar la variable a la distribución Exponencia\n          x=datos\n          curve(dexp(x), col=30, add= TRUE, lty=2, lwd = 2)\n\n        }\n\n\n    }else{\n\n\n      h4(\"Select variable is not Numeric.\")\n\n    }\n\n  }\n\n  })\n\n\n  ##FUNCIONALIDAD: MODA.\n  observeEvent(input$Boots,{\n  output$median <-renderText({\n\n    if(is.null(read_data())){\n      return()\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar])){\n        ##x<-myData[,input$listVar]\n        median(datos)\n\n\n\n      }else{\n        return()\n      }\n    }\n  }\n  )\n\n  })\n\n  observeEvent(input$listVar,{\n    output$median <-renderText({\n\n      if(is.null(read_data())){\n        return()\n      }else{\n        myData<-read_data()\n\n        if(is.numeric(myData[,input$listVar])){\n          ##x<-myData[,input$listVar]\n          median(datos)\n\n\n\n        }else{\n          return()\n        }\n      }\n    }\n    )\n\n  })\n\n\n\n  ##FUNCIONALIDAD: Desviación Standar\n  observeEvent(input$Boots,{\n  output$desv <-renderText({\n    if(is.null(read_data())){\n      return()\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar])){\n        ##x<-myData[,input$listVar]\n\n        sd(datos)\n\n      }else{\n        return()\n      }\n    }\n  }\n  )\n  })\n\n\n  observeEvent(input$listVar,{\n    output$desv <-renderText({\n      if(is.null(read_data())){\n        return()\n      }else{\n        myData<-read_data()\n\n        if(is.numeric(myData[,input$listVar])){\n          ##x<-myData[,input$listVar]\n\n          sd(datos)\n\n        }else{\n          return()\n        }\n      }\n    }\n    )\n  })\n\n\n\n  ##FUNCIONALIDAD: Varianza.\n  observeEvent(input$Boots,{\n  output$var <-renderText({\n    if(is.null(read_data())){\n      return()\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar])){\n        x<-myData[,input$listVar]\n        var(datos)\n      }else{\n        return()\n      }\n\n    }\n  }\n  )\n  })\n\n\n  observeEvent(input$listVar,{\n    output$var <-renderText({\n      if(is.null(read_data())){\n        return()\n      }else{\n        myData<-read_data()\n\n        if(is.numeric(myData[,input$listVar])){\n          x<-myData[,input$listVar]\n          var(datos)\n        }else{\n          return()\n        }\n\n      }\n    }\n    )\n  })\n\n\n  #FUNCIONALIDAD: Kurtosis\n  observeEvent(input$Boots,{\n  output$kurtosis <-renderText({\n    if(is.null(read_data())){\n      return()\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar])){\n        x<-myData[,input$listVar]\n        kurtosis(datos, na.rm = TRUE)\n      }else{\n        return()\n\n      }\n    }\n  }\n  )\n  })\n\n  observeEvent(input$listVar,{\n    output$kurtosis <-renderText({\n      if(is.null(read_data())){\n        return()\n      }else{\n        myData<-read_data()\n\n        if(is.numeric(myData[,input$listVar])){\n          x<-myData[,input$listVar]\n          kurtosis(datos, na.rm = TRUE)\n        }else{\n          return()\n\n        }\n      }\n    }\n    )\n  })\n\n\n\n  ##FUNCIONALIDAD: Sesgo\n  observeEvent(input$Boots,{\n  output$sesgo <-renderText({\n    if(is.null(read_data())){\n      return()\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar])){\n        x<-myData[,input$listVar]\n        skewness(datos, na.rm = TRUE)\n      }else{\n        return()\n      }\n\n    }\n  }\n  )\n  })\n\n  observeEvent(input$listVar,{\n    output$sesgo <-renderText({\n      if(is.null(read_data())){\n        return()\n      }else{\n        myData<-read_data()\n\n        if(is.numeric(myData[,input$listVar])){\n          x<-myData[,input$listVar]\n          skewness(datos, na.rm = TRUE)\n        }else{\n          return()\n        }\n\n      }\n    }\n    )\n  })\n\n\n\n  ##FUNCIONALIDAD: QUANTILES\n\n  observeEvent(input$Boots,{\n  output$quantil <-renderText({\n    if(is.null(read_data())){\n      return()\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar])){\n        x<-myData[,input$listVar]\n        quantile(datos, input$quantile)\n      }else{\n        return()\n      }\n\n    }\n  })\n\n  })\n\n  observeEvent(input$listVar,{\n    output$quantil <-renderText({\n      if(is.null(read_data())){\n        return()\n      }else{\n        myData<-read_data()\n\n        if(is.numeric(myData[,input$listVar])){\n          x<-myData[,input$listVar]\n          quantile(datos, input$quantile)\n        }else{\n          return()\n        }\n\n      }\n    })\n\n  })\n\n\n\n  ##FUNCIONALIDAD: Número de Observaciones\n  observeEvent(input$Boots,{\n  output$records <-renderText({\n    if(is.null(read_data())){\n      return()\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar])){\n        x<-myData[,input$listVar]\n\n        length(datos)\n      }else{\n        return()\n      }\n    }\n  }\n  )\n\n  })\n\n  observeEvent(input$listVar,{\n    output$records <-renderText({\n      if(is.null(read_data())){\n        return()\n      }else{\n        myData<-read_data()\n\n        if(is.numeric(myData[,input$listVar])){\n          x<-myData[,input$listVar]\n\n          length(datos)\n        }else{\n          return()\n        }\n      }\n    }\n    )\n\n  })\n\n\n\n  ##FUNCIONALIDAD: Generate a summary of the dataset ----\n\n  observeEvent(input$Boots,{\n  output$summary <- renderPrint({\n    if(is.null(read_data())){\n      return()\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar])){\n\n        x<-myData[,input$listVar]\n\n        summary(datos)\n      }else{\n        return()\n      }\n    }\n  })\n\n  })\n\n  observeEvent(input$listVar,{\n    output$summary <- renderPrint({\n      if(is.null(read_data())){\n        return()\n      }else{\n        myData<-read_data()\n\n        if(is.numeric(myData[,input$listVar])){\n\n          x<-myData[,input$listVar]\n\n          summary(datos)\n        }else{\n          return()\n        }\n      }\n    })\n\n  })\n\n\n\n  ##FUNCIONALIDAD: Para Ver una muestra de los datos entrados por parámetro\n  output$Data <- renderTable({\n    if(is.null(read_data())){\n      return()\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar])){\n        x<-myData[,input$listVar]\n        head(myData, n = input$obs)\n      }else{\n        return()\n\n      }\n    }\n  })\n\n\n\n  ##función para refrescar las variables disponibles del dataset de datos para que el usuario pueda seleccionar una de ellas.\n  observe({\n\n    if(is.null(read_data())){\n      return()\n    }else{\n\n      myData<-read_data()\n\n        updateSelectInput(session, \"listVar\",\n                      label = \"Variables\",\n                      choices = colnames(myData)\n        )\n\n\n\n        updateSelectInput(session, \"listvarCo\", \"Variable for Correlation:\",\n                          choices = colnames(myData)\n        )\n\n\n\n   }\n  })\n\n\n\n\n  output$Correlation  <- renderPlot({\n\n    if(is.null(read_data())){\n      return()\n\n    }else{\n      myData<-read_data()\n\n      if(is.numeric(myData[,input$listVar]) & is.numeric(myData[,input$listvarCo]) ){\n\n\n        matrix1 = cbind(myData[,input$listVar], myData[,input$listvarCo])\n\n        colnames(matrix1) <- c(input$listVar, input$listvarCo)\n\n        M<-cor(matrix1)\n\n        corrplot(M, method=\"circle\")\n\n      }else{\n\n\n\n        return()\n      }\n   }\n\n  })\n\n\n##Funciones de las SERIES DE TIEMPO:\n\n##Funcion para pintar la serie en su estado natural.\n\n  output$NaturalSerie <- renderPlot({\n\n\n    ##Se valida si hay datos leidos.\n\n    if(is.null(read_data())){\n\n    }else{\n\n\n      ##---De aquí hacia abajo no se ha cambiado nada\n\n      myData<- read_data()\n\n      #Selección de la columna que contiene la variable de análisis seleccionada por el usuario.\n\n      if(is.numeric(myData[,input$listVar])){\n\n        ##Septiembre 17 de 2017: Se valida si boostrapping está seleccionado\n        ##Si no está seleccinado, se sigue con el análisis normal\n\n\n        datos <<- myData[,input$listVar]\n\n\n        #Pintar datos\n        plot(datos, main=input$listVar,  col = 'blue', border = 'black')\n\n\n      }else{\n\n\n        h4(\"Select variable is not Numeric.\")\n\n      }\n\n    }\n\n  })\n\n  ##Fin\n\n\n  ##----------------------------SERIES DE TIEMPO---------------------------------\n\n##1.  función para obtener los datos de la serie de tiempo\n\n  observeEvent(input$Start_Year, {\n    output$TS_data <- renderPrint({\n\n\n      ##Se valida si hay datos leidos.\n\n      if(is.null(read_data())){\n\n      }else{\n\n\n        ##---De aquí hacia abajo no se ha cambiado nada\n\n        myData<- read_data()\n\n        #Selección de la columna que contiene la variable de análisis seleccionada por el usuario.\n\n        if(is.numeric(myData[,input$listVar])){\n\n          ##Septiembre 17 de 2017: Se valida si boostrapping está seleccionado\n          ##Si no está seleccinado, se sigue con el análisis normal\n\n\n           datos <<- myData[,input$listVar]\n\n\n           ##gas = scan('http://www.uam.es/joser.berrendero/datos/gas6677.dat')\n\n            print(fun_TS(datos,input$Start_Year,input$Periods,input$Frequency))\n\n        }\n      }\n\n\n  })\n  }\n  )\n\n\n##2.  Pintar Serie de tiempos:\n\n  output$Graph_TS <- renderPlot({\n\n\n    ##Se valida si hay datos leidos.\n\n    if(is.null(read_data())){\n\n    }else{\n\n\n      ##---De aquí hacia abajo no se ha cambiado nada\n\n      myData<- read_data()\n\n      #Selección de la columna que contiene la variable de análisis seleccionada por el usuario.\n\n      if(is.numeric(myData[,input$listVar])){\n\n        ##Septiembre 17 de 2017: Se valida si boostrapping está seleccionado\n        ##Si no está seleccinado, se sigue con el análisis normal\n\n\n        datos <<- myData[,input$listVar]\n\n        ##obtener la serie de tiempo\n        TS= fun_TS(datos,input$Start_Year,input$Periods,input$Frequency)\n\n        #Pintar datos\n        plot(TS, main=input$listVar,  col = 'green', border = 'black')\n\n\n      }else{\n\n\n        h4(\"Select variable is not Numeric.\")\n\n      }\n\n    }\n\n  })\n\n  ##Fin\n\n\n\n##3.  BoxPlot para comparar periodos\n\nobserveEvent(input$Frequency, {\n output$BoxPlot <- renderPlot({\n\n\n    ##Se valida si hay datos leidos.\n\n    if(is.null(read_data())){\n\n    }else{\n\n\n      ##---De aquí hacia abajo no se ha cambiado nada\n\n      myData<- read_data()\n\n      #Selección de la columna que contiene la variable de análisis seleccionada por el usuario.\n\n      if(is.numeric(myData[,input$listVar])){\n\n        ##Septiembre 17 de 2017: Se valida si boostrapping está seleccionado\n        ##Si no está seleccinado, se sigue con el análisis normal\n\n\n        datos <<- myData[,input$listVar]\n\n        ##obtener la serie de tiempo\n        TS= fun_TS(datos,input$Start_Year,input$Periods,input$Frequency)\n\n        print(input$Start_Year)\n        print(input$Periods)\n        print(input$Frequency)\n\n        ##Pinte gráfico boxplot\n        boxplot(TS~ cycle(TS),\n                medcol=c(\"#FFDB00FF\", \"#B6FF00FF\"),\n                whiskcol=c(\"#49FF00FF\", \"#00FF24FF\"),\n                staplecol=c(\"#00FF92FF\", \"#00FFFFFF\"),\n                boxcol=c(\"#0092FFFF\", \"#0024FFFF\"),\n                outcol=c(\"#4900FFFF\", \"#B600FFFF\"),\n                outbg=c(\"#FF00DB66\", \"#FF006D66\")\n        )\n\n\n      }else{\n\n\n        h4(\"Select variable is not Numeric.\")\n\n      }\n\n    }\n\n  })\n\n})\n\n  ##Fin\n\n\n ##4.  Gráfica de componentes de la Serie de tiempo:\n\n observeEvent(input$Frequency, {\n   output$ComponentPlot <- renderPlot({\n\n\n     ##Se valida si hay datos leidos.\n\n     if(is.null(read_data())){\n\n     }else{\n\n\n       ##---De aquí hacia abajo no se ha cambiado nada\n\n       myData<- read_data()\n\n       #Selección de la columna que contiene la variable de análisis seleccionada por el usuario.\n\n       if(is.numeric(myData[,input$listVar])){\n\n         ##Septiembre 17 de 2017: Se valida si boostrapping está seleccionado\n         ##Si no está seleccinado, se sigue con el análisis normal\n\n\n         datos <<- myData[,input$listVar]\n\n         ##obtener la serie de tiempo\n         TS= fun_TS(datos,input$Start_Year,input$Periods,input$Frequency)\n\n         #Optener componentes:\n         TS_COMP=decompose(TS )\n\n\n         ##Pintar gráfico:\n         plot(TS_COMP,  col = 'green', border = 'black')\n\n\n       }else{\n\n\n         h4(\"Select variable is not Numeric.\")\n\n       }\n\n     }\n\n   })\n\n }\n )\n   ##Fin\n\n\n\n ##5.  Gráfica de Tendencia (TREND)\n\n observeEvent(input$Frequency, {\n   output$Plot_Trend <- renderPlot({\n\n\n     ##Se valida si hay datos leidos.\n\n     if(is.null(read_data())){\n\n     }else{\n\n\n       ##---De aquí hacia abajo no se ha cambiado nada\n\n       myData<- read_data()\n\n       #Selección de la columna que contiene la variable de análisis seleccionada por el usuario.\n\n       if(is.numeric(myData[,input$listVar])){\n\n         ##Septiembre 17 de 2017: Se valida si boostrapping está seleccionado\n         ##Si no está seleccinado, se sigue con el análisis normal\n\n\n         datos <<- myData[,input$listVar]\n\n         ##obtener la serie de tiempo\n         TS= fun_TS(datos,input$Start_Year,input$Periods,input$Frequency)\n\n         #Optener componentes:\n         TS_COMP=decompose(TS)\n\n         ##Pintar gráfico de tendencia:\n         plot(TS_COMP$trend,  col = 'blue', border = 'black')\n\n\n       }else{\n\n\n         h4(\"Select variable is not Numeric.\")\n\n       }\n\n     }\n\n   })\n\n }\n )\n ##Fin\n\n\n\n ##6.  Gráfica de ESTACIONALIDAD (SEASON)\n\n observeEvent(input$Frequency, {\n   output$Plot_seasonal <- renderPlot({\n\n\n     ##Se valida si hay datos leidos.\n\n     if(is.null(read_data())){\n\n     }else{\n\n\n       ##---De aquí hacia abajo no se ha cambiado nada\n\n       myData<- read_data()\n\n       #Selección de la columna que contiene la variable de análisis seleccionada por el usuario.\n\n       if(is.numeric(myData[,input$listVar])){\n\n         ##Septiembre 17 de 2017: Se valida si boostrapping está seleccionado\n         ##Si no está seleccinado, se sigue con el análisis normal\n\n\n         datos <<- myData[,input$listVar]\n\n         ##obtener la serie de tiempo\n         TS= fun_TS(datos,input$Start_Year,input$Periods,input$Frequency)\n\n         #Optener componentes:\n         TS_COMP=decompose(TS )\n\n         ##Pintar gráfico de tendencia:\n         plot(TS_COMP$seasonal,  col = 'blue', border = 'black')\n\n\n       }else{\n\n\n         h4(\"Select variable is not Numeric.\")\n\n       }\n\n     }\n\n   })\n\n }\n )\n ##Fin\n\n\n\n ##7.  Gráfica de RESIDUOS (CAMBIOS DE LA SERIE IMPREDECIBLES)\n\n observeEvent(input$Frequency, {\n   output$Plot_Residual <- renderPlot({\n\n\n     ##Se valida si hay datos leidos.\n\n     if(is.null(read_data())){\n\n     }else{\n\n\n       ##---De aquí hacia abajo no se ha cambiado nada\n\n       myData<- read_data()\n\n       #Selección de la columna que contiene la variable de análisis seleccionada por el usuario.\n\n       if(is.numeric(myData[,input$listVar])){\n\n         ##Septiembre 17 de 2017: Se valida si boostrapping está seleccionado\n         ##Si no está seleccinado, se sigue con el análisis normal\n\n\n         datos <<- myData[,input$listVar]\n\n         ##obtener la serie de tiempo\n         TS= fun_TS(datos,input$Start_Year,input$Periods,input$Frequency)\n\n         #Optener componentes:\n         TS_COMP=decompose(TS )\n\n         ##Pintar gráfico de tendencia:\n         plot(TS_COMP$random,  col = 'blue', border = 'black')\n\n\n       }else{\n\n\n         h4(\"Select variable is not Numeric.\")\n\n       }\n\n     }\n\n   })\n\n }\n )\n ##Fin\n\n\n\n\n\n }\n\n\n",
    "created" : 1506389473760.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2963511382",
    "id" : "561A705D",
    "lastKnownWriteTime" : 1506293243,
    "last_content_update" : 1506293243,
    "path" : "~/GitHub/Series-Tiempo/R/server.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}